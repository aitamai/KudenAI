# 02_認証・認可フロー（現行システム）

## コンポーネント
- **Django Auth + Django-OTP**: メール/パスワード認証後に OTP フェーズへ移行し、完全ログインは 2FA 成功後のみ成立
- **Redis**: `otp:{user_id}` に5分 TTL でワンタイムコード保管、`pwdreset:{token}` を10分 TTL で保管、`session:{user_id}` にマルチセッションキーを保存
- **メール送信**: SendGrid 等で OTP/パスワードリセットリンクを配信（UUID4 or `secrets.token_urlsafe(32)` を利用）
- **RBAC + Plan Gate**: ユーザーロール（user/creator/admin/operator）とプラン（Free/Pro/Business）で API を制御。プライバシーフラグ（AI公開可否/機密項目）を評価
- **ログ/監査**: `audit_logs` と Langfuse trace に OTP 成功/失敗、再送、ロック状態を保存

## 認証フロー
1. **新規登録画面**（レスポンシブ/PWA）でメール・パスワード・プロフィール初期値を入力
2. Django 側で `authenticate(username, password)` → 成功した時点ではまだログイン不可
3. Django-OTP で6桁または TOTP を発行し、Redis に保存。ユーザーへメール/SMS/Authenticator のいずれかで提示
4. フロントの OTP 画面でコード入力 → Redis 比較一致かつ TTL 内であれば本ログイン成立
5. セッションキーを `session:{user_id}:{uuid}` の形式で Redis に登録し、同時複数端末を許容。キー削除で特定端末をリモートログアウト
6. 5回連続失敗で `user.status=locked` に設定し、Celery から通知・管理者承認で解除

## OTP/2FA 運用
- OTP の再送は 30 秒クールダウン
- デバイス信頼設定は行わず、毎回 OTP を必須（BFF 層で remember me フラグはセッション延長にのみ使用）
- Django-OTP の `PersistentDevice` で TOTP もサポート。Authenticator アプリの登録/削除はプロフィール画面から実行
- Langfuse に OTP trace を残し、異常増加を CloudWatch + Slack に通知

## パスワードリセット
1. ログイン画面下部の「パスワードを忘れた場合」リンクを押下
2. メールアドレス入力 → Django がトークンを生成し Redis に TTL=10分で保存
3. メールリンク経由で再設定画面へ。トークン一致で新パスワードをセットし、全セッションを削除 (`session:{user_id}:*`)
4. 成功後は監査ログに記録し、メール通知。トークンは即時削除

## 認可ポリシー
- **RBAC**: admin がユーザー・AI 公開設定・課金を管理、creator が AI 公開や収益画面にアクセス、operator が通報審査/台帳調整を実施
- **リソーススコープ**: API は `user_id` + `avatar_id` 権限を検証。日記は完全プライベート、共有フラグ付きのみ RAG で引用可
- **プラン制限**: 会話/日記/AI公開数に応じた上限を `usage_counters` でチェックし、超過時は追加トークン購入導線を返す
- **機密属性**: プロフィールの機密チェックボックスが ON の項目は AES 列暗号化し、管理 UI 側でもマスク表示

## 監査・可視化
- OTP 成功/失敗、パスワードリセット、公開設定変更を `admin_events`/`audit_logs` に記録
- Langfuse trace と `token_ledger` ID を紐付け、不正アクセスや利用量急増を検知
- CloudWatch + Sentry で 5xx、OTP 失敗の急増、レイテンシ悪化をアラート

